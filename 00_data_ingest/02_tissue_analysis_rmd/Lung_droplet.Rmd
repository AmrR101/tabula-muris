---
 title: "Lung Droplet Notebook"
 output: html_notebook
---

Enter the directory of the maca folder on your drive and the name of the tissue you want to analyze.

```{r}
tissue_of_interest = "Lung"
```

Load the requisite packages and some additional helper functions.

```{r}
library(here)
library(useful)
library(Seurat)
library(dplyr)
library(Matrix)
library(ontologyIndex)
cell_ontology = get_ontology('https://raw.githubusercontent.com/obophenotype/cell-ontology/master/cl-basic.obo', extract_tags='everything')

validate_cell_ontology = function(cell_ontology_class){
  in_cell_ontology = sapply(cell_ontology_class, function(x) is.element(x, cell_ontology$name) || is.na(x))
  if (!all(in_cell_ontology)) {
    message = paste0('"', cell_ontology_class[!in_cell_ontology], '" is not in the cell ontology
')
    stop(message)
  }
}
convert_to_cell_ontology_id = function(cell_ontology_class){
  return(sapply(cell_ontology_class, function(x) as.vector(cell_ontology$id[cell_ontology$name == x])[1]))
}
save_dir = here('00_data_ingest', '04_tissue_robj_generated')
```



```{r}
# read the metadata to get the plates we want
droplet_metadata_filename = here('00_data_ingest', '01_droplet_raw_data', 'metadata_droplet.csv')

droplet_metadata <- read.csv(droplet_metadata_filename, sep=",", header = TRUE)
colnames(droplet_metadata)[1] <- "channel"
droplet_metadata
```

Subset the metadata on the tissue.

```{r}
tissue_metadata = filter(droplet_metadata, tissue == tissue_of_interest)[,c('channel','tissue','subtissue','mouse.sex')]
tissue_metadata
```


Use only the metadata rows corresponding to Bladder plates. Make a plate barcode dataframe to "expand" the per-plate metadata to be per-cell.

```{r}
# Load the gene names and set the metadata columns by opening the first file

subfolder = paste0(tissue_of_interest, '-', tissue_metadata$channel[1])
raw.data <- Read10X(data.dir = here('00_data_ingest', '01_droplet_raw_data', 'droplet', subfolder))
colnames(raw.data) <- lapply(colnames(raw.data), function(x) paste0(tissue_metadata$channel[1], '_', x))
meta.data = data.frame(row.names = colnames(raw.data))
meta.data['channel'] = tissue_metadata$channel[1]

if (length(tissue_metadata$channel) > 1){
  # Some tissues, like Thymus and Heart had only one channel
  for(i in 2:nrow(tissue_metadata)){
    subfolder = paste0(tissue_of_interest, '-', tissue_metadata$channel[i])
    new.data <- Read10X(data.dir = here('00_data_ingest', '01_droplet_raw_data', 'droplet', subfolder))
    colnames(new.data) <- lapply(colnames(new.data), function(x) paste0(tissue_metadata$channel[i], '_', x))
    
    new.metadata = data.frame(row.names = colnames(new.data))
    new.metadata['channel'] = tissue_metadata$channel[i]
    
    raw.data = cbind(raw.data, new.data)
    meta.data = rbind(meta.data, new.metadata)
  }
}

rnames = row.names(meta.data)
meta.data <- merge(meta.data, tissue_metadata, sort = F)
row.names(meta.data) <- rnames
```

Process the raw data and load it into the Seurat object.

```{r}
# Find ERCC's, compute the percent ERCC, and drop them from the raw data.
erccs <- grep(pattern = "^ERCC-", x = rownames(x = raw.data), value = TRUE)
percent.ercc <- Matrix::colSums(raw.data[erccs, ])/Matrix::colSums(raw.data)
ercc.index <- grep(pattern = "^ERCC-", x = rownames(x = raw.data), value = FALSE)
raw.data <- raw.data[-ercc.index,]

# Create the Seurat object with all the data
tiss <- CreateSeuratObject(raw.data = raw.data, project = tissue_of_interest, 
                    min.cells = 5, min.genes = 5)

tiss <- AddMetaData(object = tiss, meta.data)
tiss <- AddMetaData(object = tiss, percent.ercc, col.name = "percent.ercc")
# Change default name for sums of counts from nUMI to nReads
# colnames(tiss@meta.data)[colnames(tiss@meta.data) == 'nUMI'] <- 'nReads'

# Create metadata columns for cell_ontology_classs and subcell_ontology_classs
tiss@meta.data[,'cell_ontology_class'] <- NA
tiss@meta.data[,'subcell_ontology_class'] <- NA
```


Calculate percent ribosomal genes.

```{r}
ribo.genes <- grep(pattern = "^Rp[sl][[:digit:]]", x = rownames(x = tiss@data), value = TRUE)
percent.ribo <- Matrix::colSums(tiss@raw.data[ribo.genes, ])/Matrix::colSums(tiss@raw.data)
tiss <- AddMetaData(object = tiss, metadata = percent.ribo, col.name = "percent.ribo")
```

A sanity check: genes per cell vs reads per cell.

```{r}
GenePlot(object = tiss, gene1 = "nUMI", gene2 = "nGene", use.raw=T)
```

Filter out cells with few reads and few genes.

```{r}
tiss <- FilterCells(object = tiss, subset.names = c("nGene", "nUMI"), 
    low.thresholds = c(500, 1000), high.thresholds = c(25000, 5000000))
```


Normalize the data, then regress out correlation with total reads
```{r}
tiss <- NormalizeData(object = tiss)
tiss <- ScaleData(object = tiss)
tiss <- FindVariableGenes(object = tiss, do.plot = TRUE, x.high.cutoff = Inf, x.low.cutoff = 0.25, y.cutoff = 0.5)
```


Run Principal Component Analysis.
```{r}
tiss <- RunPCA(object = tiss, do.print = FALSE)
tiss <- ProjectPCA(object = tiss, do.print = FALSE)
```

```{r, echo=FALSE, fig.height=4, fig.width=8}
PCHeatmap(object = tiss, pc.use = 10:20, cells.use = 500, do.balanced = TRUE, label.columns = FALSE, num.genes = 8)
```

Later on (in FindClusters and TSNE) you will pick a number of principal components to use. This has the effect of keeping the major directions of variation in the data and, ideally, supressing noise. There is no correct answer to the number to use, but a decent rule of thumb is to go until the plot plateaus.

```{r}
PCElbowPlot(object = tiss)
```

Choose the number of principal components to use.
```{r}
# Set number of principal components. 
n.pcs = 20
```


The clustering is performed based on a nearest neighbors graph. Cells that have similar expression will be joined together. The Louvain algorithm looks for groups of cells with high modularity--more connections within the group than between groups. The resolution parameter determines the scale...higher resolution will give more clusters, lower resolution will give fewer.

For the top-level clustering, aim to under-cluster instead of over-cluster. It will be easy to subset groups and further analyze them below.

```{r}
# Set resolution 
res.used <- 3

tiss <- FindClusters(object = tiss, reduction.type = "pca", dims.use = 1:n.pcs, 
    resolution = res.used, print.output = 0, save.SNN = TRUE)
```


To visualize 
```{r}
# If cells are too spread out, you can raise the perplexity. If you have few cells, try a lower perplexity (but never less than 10).
tiss <- RunTSNE(object = tiss, dims.use = 1:n.pcs, seed.use = 10, perplexity=30, dim.embed = 2)
```

```{r}
# note that you can set do.label=T to help label individual clusters
TSNEPlot(object = tiss, do.label = T)
```

Check expression of genes of interset.

Gross tissue breakdown
```{r}
genes_to_check = c('Pecam1', 'Epcam', 'Col1a1', 'Ptprc')

FeaturePlot(tiss, genes_to_check, pt.size = 1, cols.use = c('grey', 'red'))
```

```{r}
genes_to_check = c('Sftpb', 'Foxj1', 'Ager', 'Scgb1a1')

FeaturePlot(tiss, genes_to_check, pt.size = 1, cols.use = c('grey', 'red'))
```

```{r}
genes_to_check = c('Resp18', 'Scgb3a2', 'Pdpn', 'Wnt3a')

FeaturePlot(tiss, genes_to_check, pt.size = 1, cols.use = c('grey', 'red'))
```

Seperating Seurat's mess with the epithelial cell types...

```{r}
if (!require("gplots")) {
  install.packages("gplots", dependencies = TRUE)
  library(gplots)
}
if (!require("RColorBrewer")) {
  install.packages("RColorBrewer", dependencies = TRUE)
  library(RColorBrewer)
}

my_palette <- colorRampPalette(rev(brewer.pal(n=10,name="RdYlBu")))(25)

gg_color_hue <- function(n) {
  hues = seq(15, 375, length = n + 1)
  hcl(h = hues, l = 65, c = 100)[1:n]
}

heatmap.2(as.matrix(tiss@scale.data[c('Col1a1', 'Epcam', 'Cdh1', 'Etv5', 'Pecam1', 'Ncam1', 'Ptprc', 'Sftpb', 'Sftpd', 'Ager', 'Pdpn', 'Wnt3a', 'Calca', 'Resp18', 'Scgb3a2', 'Scgb1a1', 'Foxj1', 'Krt5', 'Gpx3', 'Foxa3'),WhichCells(tiss, c(23,17,25))]), distfun = function(x) dist(x, method = 'euclidean'), hclustfun = function(x) hclust(x, method = 'ward.D2'), symbreaks = F, symkey = F,  key.title = '', col=my_palette, trace="none", Rowv = T, Colv = T, key.xlab = expression('log'[2] ~ 'Scaled UPM + 1'), key.ylab = '', density.info = 'density', denscol = 'black', margins = c(3,6), cexRow = 0.8, ColSideColors = gg_color_hue(33)[tiss@ident[WhichCells(tiss, c(23,17,25))]])

ident.tmp = as.numeric(as.character(tiss@ident))
names(ident.tmp) = names(tiss@ident)

#Club Cell Reassignment
ident.tmp[names(which(tiss@scale.data['Scgb3a2',WhichCells(tiss, c(23,17,25))] > 9))] = 28

#NE
ident.tmp[names(which(tiss@scale.data['Calca',WhichCells(tiss, c(23,17,25))] > 6))] = 29

#Ciliated Cells
ident.tmp[names(which(tiss@scale.data['Foxj1',WhichCells(tiss, c(23,17,25))] > 5))] = 30

#Type I AECs
ident.tmp[names(which(tiss@scale.data['Ager',WhichCells(tiss, c(23,17,25))] > 5))] = 31

```



```{r}
genes_to_check = c('Cd8a', 'Cd79a', 'Klrb1c', 'Cd3e')

FeaturePlot(tiss, genes_to_check, pt.size = 1, cols.use = c('grey', 'red'))
```

```{r}
genes_to_check = c('Slc38a5', 'Trpc6', 'Serpinf1', 'Gpx3')

FeaturePlot(tiss, genes_to_check, pt.size = 1, cols.use = c('grey', 'red'))
```

```{r}
genes_to_check = c('Myh11', 'Cspg4', 'Msln', 'Acta2')
FeaturePlot(tiss, genes_to_check, pt.size = 1, cols.use = c('grey', 'red'))
```

```{r}
genes_to_check = c('Aplnr', 'Car4', 'Gja5')

FeaturePlot(tiss, genes_to_check, pt.size = 1, cols.use = c('grey', 'red'))
```

```{r}
genes_to_check = c('Apln', 'Amigo2', 'Kit', 'Car8')

FeaturePlot(tiss, genes_to_check, pt.size = 1, cols.use = c('grey', 'red'))
```

```{r}
heatmap.2(as.matrix(tiss@scale.data[c('Car4', 'Car8', 'Gja5', 'Amigo2', 'Aplnr', 'Pecam1'),WhichCells(tiss, c(14))]), distfun = function(x) dist(x, method = 'euclidean'), hclustfun = function(x) hclust(x, method = 'ward.D2'), symbreaks = F, symkey = F,  key.title = '', col=my_palette, trace="none", Rowv = T, Colv = T, key.xlab = expression('log'[2] ~ 'Scaled UPM + 1'), key.ylab = '', density.info = 'density', denscol = 'black', margins = c(3,6), cexRow = 0.8, ColSideColors = gg_color_hue(33)[tiss@ident[WhichCells(tiss, c(14))]])

ident.tmp[setdiff(unique(c(names(which(tiss@scale.data['Amigo2',WhichCells(tiss, c(14))] > 0)), names(which(tiss@scale.data['Car8',WhichCells(tiss, c(14))] > 0)), names(which(tiss@scale.data['Gja5',WhichCells(tiss, c(14))] > 0)))), unique(c(names(which(tiss@scale.data['Aplnr',WhichCells(tiss, c(14))] > 0)), names(which(tiss@scale.data['Car4',WhichCells(tiss, c(14))] > 0)))))] = 33

tiss@ident = as.factor(ident.tmp)


heatmap.2(cor(as.matrix(tiss@scale.data[tiss@var.genes,WhichCells(tiss, c(14,33))])), distfun = function(x) dist(x, method = 'euclidean'), hclustfun = function(x) hclust(x, method = 'ward.D2'), symbreaks = F, symkey = F,  key.title = '', col=my_palette, trace="none", Rowv = T, Colv = T, key.xlab = expression('log'[2] ~ 'R'), key.ylab = '', density.info = 'density', denscol = 'black', margins = c(3,6), cexRow = 0.8, ColSideColors = gg_color_hue(33)[tiss@ident[WhichCells(tiss, c(14,33))]])


search = tiss@scale.data[tiss@var.genes,WhichCells(tiss,c(14,33))]
finalResults <- as.numeric(matrix(0,c(length(colnames(search)),1)))
names(finalResults) <- colnames(search)
testVector = Matrix::rowMeans(tiss@scale.data[tiss@var.genes,WhichCells(tiss,c(33))])
finalResults = apply( search , 2 , cor , y = testVector, method = "pearson" )
ident.tmp[names(finalResults[which(finalResults > 0.7)])] = 33

tiss@ident = as.factor(ident.tmp)

heatmap.2(cor(as.matrix(tiss@scale.data[tiss@var.genes,WhichCells(tiss, c(14,33))])), distfun = function(x) dist(x, method = 'euclidean'), hclustfun = function(x) hclust(x, method = 'ward.D2'), symbreaks = F, symkey = F,  key.title = '', col=my_palette, trace="none", Rowv = T, Colv = T, key.xlab = expression('log'[2] ~ 'R'), key.ylab = '', density.info = 'density', denscol = 'black', margins = c(3,6), cexRow = 0.8, ColSideColors = gg_color_hue(33)[tiss@ident[WhichCells(tiss, c(14,33))]])

```


```{r}
genes_to_check = c('Csf1r', 'Itgax', 'Ly6c2', 'H2-Aa')

FeaturePlot(tiss, genes_to_check, pt.size = 1, cols.use = c('grey', 'red'))
```

```{r}
genes_to_check = c('Marco', 'Itgax', 'Mrc1', 'Entpd2')

FeaturePlot(tiss, genes_to_check, pt.size = 1, cols.use = c('grey', 'red'))
```

```{r}
genes_to_check = c('Itgax', 'Cd24a', 'Cd68', 'Marco')
FeaturePlot(tiss, genes_to_check, pt.size = 1, cols.use = c('grey', 'red'))
```


```{r}
genes_to_check = c('Cx3cr1', 'Cd14', 'Itgam')

FeaturePlot(tiss, genes_to_check, pt.size = 1, cols.use = c('grey', 'red'))
```

```{r}
genes_to_check = c('Il3ra', 'Cd14', 'Cd19', 'Ccr2')

FeaturePlot(tiss, genes_to_check, pt.size = 1, cols.use = c('grey', 'red'))
```

Sorting out Seurat on the myeloid cells..
```{r}
heatmap.2(as.matrix(tiss@scale.data[c('Epcam', 'Cdh1', 'Pecam1', 'Ncam1', 'Ptprc', 'Csf1r', 'Itgax', 'Ly6c2', 'H2-Aa', 'Mrc1', 'Itgam', 'Cx3cr1', 'Cd14'),WhichCells(tiss, c(20,10,15,24))]), distfun = function(x) dist(x, method = 'euclidean'), hclustfun = function(x) hclust(x, method = 'ward.D2'), symbreaks = F, symkey = F,  key.title = '', col=my_palette, trace="none", Rowv = T, Colv = T, key.xlab = expression('log'[2] ~ 'CPM + 1'), key.ylab = '', density.info = 'density', denscol = 'black', margins = c(3,6), cexRow = 0.8, ColSideColors = gg_color_hue(27)[tiss@ident[WhichCells(tiss, c(20,10,15,24))]])

ident.tmp[intersect(intersect(names(which(tiss@scale.data['Csf1r',WhichCells(tiss, c(20))] > 0)), names(which(tiss@scale.data['Mrc1',WhichCells(tiss, c(20))] > 0))), names(which(tiss@scale.data['Cd14',WhichCells(tiss, c(20))] > 0)))] = 32


```


Color by metadata, like plate barcode, to check for batch effects.
```{r}
TSNEPlot(object = tiss, do.return = TRUE, group.by = "channel")
```


How big are the clusters?
```{r}
table(tiss@ident)
```



Which markers identify a specific cluster?

```{r}
tiss10x.27.markers <- FindMarkers(object = tiss, ident.1 = c(27), only.pos = TRUE, min.pct = 0.25, thresh.use = 0.25)
```


```{r}
print(x = head(x= clust.markers, n = 10))
```

You can also compute all markers for all clusters at once. This may take some time.
```{r}
#tiss.markers <- FindAllMarkers(object = tiss, only.pos = TRUE, min.pct = 0.25, thresh.use = 0.25)
```

Display the top markers you computed above.
```{r}
#tiss.markers %>% group_by(cluster) %>% top_n(5, avg_diff)
```

But first, "committing" to the new idents...
```{r}
#Uncomment to undo this...
#tiss@ident = old.idents

#old.idents = tiss@ident
tiss@ident = as.factor(ident.tmp)

```


```{r}
# note that you can set do.label=T to help label individual clusters
TSNEPlot(object = tiss, do.label = T)
```

## Assigning cell type identity to clusters

At a coarse level, we can use canonical markers to match the unbiased clustering to known cell types:

```{r}
# stash current cluster IDs
tiss <- StashIdent(object = tiss, save.name = "cluster.ids")

cluster.ids <- 0:33

# enumerate current cluster IDs and the labels for them

free_annotation <- c(
  "lung stromal type 2 cell", 
  "lung stromal type 2 cell", 
  "natural killer cell", 
  "lung stromal type 3 cell",
  "lung stromal type 1 cell",
  "alveolar macrophage", 
  "lung stromal type 2 cell", 
  "t cell", 
  "lung stromal type 2 cell", 
  "lung endothelial type 1 cell",
  "circulating monocyte",
  "b cell",
  "natural killer cell",
  "natural killer cell",
  "lung endothelial type 1 cell",
  "invading monocyte",
  "lung stromal type 4 cell",
  "lung stromal type 2 cell",
  "unknown immune cell",
  "lung stromal type 1 cell",
  "dendritic cell",
  "alveolar epithelial type 2 cell",
  "lung endothelial type 2 cell",
  "lung epithelial cell",
  "unknown immune cell",
  "lung epithelial cell",
  "natural killer cell",
  NA,
  "club cell",
  "lung neuroendocrine cell",
  "multiciliated cell",
  "alveolar epithelial type 1 cell",
  "interstital macrophage",
  "lung endothelial type 3 cell")


cell_ontology_class <-c(
  "stromal cell", 
  "stromal cell", 
  "natural killer cell", 
  "stromal cell",
  "stromal cell",
  "alveolar macrophage", 
  "stromal cell", 
  "T cell", 
  "stromal cell", 
  "lung endothelial cell",
  "non-classical monocyte",
  "B cell",
  "natural killer cell",
  "natural killer cell",
  "lung endothelial cell",
  "classical monocyte",
  "stromal cell",
  "stromal cell",
  "leukocyte",
  "stromal cell",
  "dendritic cell",
  "type II pneumocyte",
  "lung endothelial cell",
  "epithelial cell of lung",
  "leukocyte",
  "epithelial cell of lung",
  "natural killer cell",
  NA,
  "Clara cell",
  "lung neuroendocrine cell",
  "ciliated columnar cell of tracheobronchial tree",
  "type I pneumocyte",
  "lung macrophage",
  "lung endothelial cell")


tiss@meta.data['free_annotation'] <- as.character(plyr::mapvalues(x = tiss@ident, from = cluster.ids, to = free_annotation))

validate_cell_ontology(cell_ontology_class)
cell_ontology_id = convert_to_cell_ontology_id(cell_ontology_class)

tiss@meta.data['cell_ontology_id'] <- as.character(plyr::mapvalues(x = tiss@ident, from = cluster.ids, to = cell_ontology_id))

tiss@meta.data['cell_ontology_class'] <- as.character(plyr::mapvalues(x = tiss@ident, from = cluster.ids, to = cell_ontology_class))

TSNEPlot(object = tiss, do.label = TRUE, pt.size = 0.5, group.by='free_annotation', no.axes = TRUE, no.legend = TRUE)

TSNEPlot(object = tiss, do.label = TRUE, pt.size = 0.5, group.by='cell_ontology_class', no.axes = TRUE, no.legend = TRUE)
```


## Checking for batch effects


Color by metadata, like plate barcode, to check for batch effects.
```{r}
TSNEPlot(object = tiss, do.return = TRUE, group.by = "channel")
```

```{r}
TSNEPlot(object = tiss, do.return = TRUE, group.by = "mouse.sex")
```

Print a table showing the count of cells in each identity category from each plate.

```{r}
table(as.character(tiss@ident), as.character(tiss@meta.data$channel))
```
